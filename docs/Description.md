# Описание системы
## Введение
Данная система представляет собой комплекс, состоящий из трёх сервисов, взаимодействующих с 2-3 базами данных. Состав системы: 
- Router - сервис, предназначенный для маршрутизации запросов пользователя между различными экземплярами TaskService и StateService. Кроме того, он предоставляет TaskService адреса StateService для получения статусов выполнения заданий
- TaskService - сервис, роль которого - передача клиенту зписка заданий и статусов выполненности заданий, полученных от StateService
- StateService - сервис, задачей которого является добавление записей об изменении статуса задания, а также предоставление этих статусов
Кроме того, что относится к бэкенду, были разработаны стратический макет страницы, скрипт для её реактивного заполнения, а также файл стилей в качестве фронтенда для удобного тестирования работы сервера.
## Используемые технологии
Разработка серверной части приложения велась с помощью Node.js. Данный выбор даёт высокую скорость работы приложению, несмотря на однопоточность Node.js. При этом существуют способы запуска нескольких экземпляров одного приложения на одном порту, что сделает приложение ещё быстрее.</br>
Для франения информации о заданиях были выбраны реляционные СУБД, в частности MySQL. Не смотря на то, что документарные базы часто быстрее и проще в масштабировнии, выявленная структура БД имеет чисто табличный вид. Кроме того, при работе с БД была выявлена необходимость использования оператора соединения (JOIN), который отсутствуе в нереляционных СУБД. Созданный сервер может вести работу как с одной, так и с двумя отдельными базами данных.</br>
Кроме MySQL на сервере используется хранилище Redis для хранения сессий клиентов. Таким образом, все сессии хранятся в едином очень быстром хранилище.</br>
На клиентской стороне была создана простейшая страница на HTML, разработан дизайн различных элементов, появляющихся на странице в помощью  CSS.</br>
Основной частью фронтенда является крупный скрипт, созданный с помощью Vue.js. Этот скрипт позволяет использовать только одну страницу для ситуационного отображения объектов, необходимых в конкретный момент.Таким образом, это минимизирует нагрузку на router, ведь ему надо будет для каждого клиента передать определённый набор файлов и два адреса. После этого взаимодействие пользователя с router'ом полностью заканчивается. Это позволяет сильно увеличить скорость ответа маршрутизатора и, как следствие, количество обслуживаемых клиентов за единцу времени.
## Инструкция по запуску
### Необходимое ПО
Созданная система является полностью кроссплатформенной. Все нобходимые компоненты могут быть настроены и запущены на любой операционной системе.</br>
Важно, что Redis официально не поддерживается для Windows, но при этом официальная страница Redis labs даёт ссылку на [репозиторий](https://github.com/dmajkic/redis/downloads), где можно скачать Redis под Windows. Кроме того, в Windows 10 возможна установка компонента Подсистема Windows для Linux, который позволяет запускать оболочку Linux в пользовательском интерфейсе Windows.</br>
Для корректной работы сервиса необходимо установить MySQL Server. На [официальном сайте](https://dev.mysql.com/downloads/) можно также найти все инструкции по установке MySQL.</br>
Для установки Node.js необходимо перейти на [официальный сайт](https://nodejs.org/en/download/) и скачать подходящую сборку.
### Предварительная настройка
Перед запуском основных сервисов необходимо провести настройку их конфигурационных файлов и окружения.</br>
Перед каждым запуском основных сервисов необходимо удостоверится в работе MySQL и Redis. Если не работает Redis, необходимо его запустить командой `redis-server` (запустить `redis-server.exe` из скаченногого архива для Windows). Если не включен MySQL сервер стоит запустить:
- команду `sudo service mysql start` для дистрибутивов Linux Debian u Ubuntu;
- команду `mysql.server start` для Mac OSX;
- MySQL Shell для Windows.
После проверки окружения перед первым запуском необходимо настроить конфигурационные файлы каждого из сервисов.
#### Router
В файл `hosts.json` необходимо внести данные обо всех копиях сервисов taskService и stateService в виде массивов в соответствующие поля.
Для файла `config.json` необходимо внести в:
- `countOfThreads` количество потоков, которые может использовать приложение. Если на машине планируется запускать только данный сервис, то имеет смысл указать значение на единицу меньше чем количество ядер процессора;
- `host` адрес, на котором будет запущен сервис;
- `port` порт, который будет прослушивать сервис;
- `pages` список разрешённых путей и соответствующих им файлов. Настраивать не надо, если сервис запускается без изменений.
#### TaskService и StateService
Для файла `config.json` необходимо внести в:
- `countOfThreads` количество потоков, которые может использовать приложение. Если на машине планируется запускать только данный сервис, то имеет смысл указать значение на единицу меньше чем количество ядер процессора;
- `host` адрес, на котором будет запущен сервис;
- `port` порт, который будет прослушивать сервис;
- `redisHost` адрес, по которому находится запущенное Redis хранилище;
- `redisPort` порт, который прослушивает Redis хранилище;
- `dbHost` адрес MySQL сарвера с базой данных для данного сервиса;
- `dbPort` порт, прослушиваемый MySQL сервером;
- `dbName` название базы данных;
- `dbUser` имя пользователя БД;
- `dbPass` пароль пользователя БД;
- `sessionSecret` строка для шифрования сессий;
- `router` адрес сервиса Router. **Важо помнить**, что адрес, указанный в данном поле должен полностью совпадать с адресом, по которому будет происходить обращение пользователя к router в соответствии с CORS policy.
### Порядок запуска компонентов
Для запуска всех сервисов используется одна и та же команда `node index.js`, выполненная в командной строке или терминале из корневой директории каждого сервиса.</br>
Все сервисы должны запускаться в определённом порядке, иначе первые запросы, направленные на TaskService будут обрабатываться с некоторой задержкой, связанной с получением адреса StateService.
Очередь запуска сервисов:
1. Запустить все экземпляры StateService
2. Запустить Router (только в одном экземпляре, так как он также выступает в виде DNS балансировщика)
3. Запустить все экземпляры TaskService
## Система взаимодействия с сервисами
Основной функционал сервисов заключается во взаимодействии с клиентом с помощью API на основе протокола удалённого вызова функций JSON RPC 2.0 через POST запросы. Данный протокол реализован в системе не в полной мере и с определёнными отступлениями от спецификации 2.0. Во-первых, данной системе не требуются batch-запросы, что избавляет от определения уникальных id запросов. Из-за этого во всех запросах это поле по умолчанию заполнено нулями. Во-вторых, параметры передаются в виде объекта, а не массивом. Данный шаг был произведён для увеличения понятноси API. Последнее отличие от спецификации - это передача некоторых ошибок не специальном поле error, а в поле result. В этих случаях ответ ERROR является именно результатом работы функции, а не ошибкой. Более подробно о структуре запросов, ответов и функционале в целом можно узнать в [описании API](API%20documentation.md).
## Авторизация в системе
Для использования полного функционала необходимо произвести авторизацию в системе. Так как взаимодействие клиента с сервером происходит через протокол HTTP, все подходы к защите можно расположить на отрезке, в начале которого будут находиться совсем ненадёжные методы, а в другом - методы, требующие вычислительные мощности. Для авторизации в системе используется вариант, находящийся ближе к середине этого отрезка. Алгоритм валидации построен на использовании валидации хэшей, полученных с помощью медленной хэш-функции `bcrypt`</br>
Процесс авторизации происходит только через TaskService. В его базе данных хранится имя пользователя, его номер и хэш пароля. Авторизация происходит в два шага.
#### Первый шаг: получение соли
Первый шаг входа в систему состоит в получении клиентом соли (`salt1`), от сервера. Серверу нет необходимости хранить соль в отдельном месте, так как она содержится в первых 29 символах хэша пароля.
#### Второй шаг: валидация
В рамках второго шага, после получения `salt1`, на клиенте дважды выполняет хэширование пароля - первый раз с использованием `salt1`, второй, используя новую случайную соль (`salt2`). После этого полученный хэш передаётся на сервер, на его основе считается хэш функция от данных из базы данных и `salt2` и сравнивается с хэшем клиента.</br></br>
Для сервиса TaskService сессия не создаётся, так как тогда пришлось бы авторизовываться (авторизация необходма для доступа к StateService) каждые два часа, что привело бы к задержкам и лишним ошибкам. Таким образом, StateService, получая запрос от неавторизованного пользователя посылает запрос к Router, который проверяет, относится ли адрес в адресах TaskService.
## Масштабирование сервисов
Для реализации масштабирования системы было использовано несколько механизмов.
### Средства Node.js
У Node.js имеется определённая особенность, однопоточность. Это обозначает, что машина, имеющая восмиядерный процессор, будет использовать лишь один. Во избежание неполного использования ресурсов, а также для увеличения скорости работы сервисов используется встроенный модуль `cluster`, позволяющий запустить написанные сервисы в несколько потоков. При этом все копии запускаются и корректно работают на одном порте. Для оптимальной работы сервисов количество потоков должно быть меньше ядер процессора на 1, так как управляющий поток то же будет расходовать определённыйе ресурсы. Для этого метода используется стандартный алгоритм балансировки нагрузки RoundRobin.
### DNS балансировка
Для реализации балансировки нагрузки между экземплярами сервисов, распределённых по разным физическим машинам, используется механизм близкий к DNS балансировке. В данной системе в качестве балансировщика используется Router. В его задачи входит отдать клиенту адреса TaskService и StateService, а также заменят адреса, если они не работают.</br>
Для получения адресов Router используется клиентом (для получения адресов TaskService и StateService) и TaskService (для получения адресов StateService). При получении запроса он отдаут по одному адресу каждого требуемого адреса. Если в процессе работы запрос на выданный адрес осуществить не удаётся. На Router посылается запрос на получение нового адреса и удаления текущего из памяти Router.</br>
Для считывания нового списка адресов из `hosts.json` ноебходимо выполнить запрос по пути `/refresh`
