# Описание системы
## Введение
Данная система представляет собой комплекс, состоящий из трёх сервисов, взаимодействующих с 2-3 базами данных. Состав системы: 
- Router - сервис, предназначенный для маршрутизации запросов пользователя между различными экземплярами TaskService и StateService. Кроме того, он предоставляет TaskService адреса StateService для получения статусов выполнения заданий
- TaskService - сервис, роль которого - передача клиенту зписка заданий и статусов выполненности заданий, полученных от StateService
- StateService - сервис, задачей которого является добавление записей об изменении статуса задания, а также предоставление этих статусов
Кроме того, что относится к бэкенду, были разработаны стратический макет страницы, скрипт для её реактивного заполнения, а также файл стилей в качестве фронтенда для удобного тестирования работы сервера.
## Используемые технологии
Разработка серверной части приложения велась с помощью Node.js. Данный выбор даёт высокую скорость работы приложению, несмотря на однопоточность Node.js. При этом существуют способы запуска нескольких экземпляров одного приложения на одном порту, что сделает приложение ещё быстрее.</br>
Для франения информации о заданиях были выбраны реляционные СУБД, в частности MySQL. Не смотря на то, что документарные базы часто быстрее и проще в масштабировнии, выявленная структура БД имеет чисто табличный вид. Кроме того, при работе с БД была выявлена необходимость использования оператора соединения (JOIN), который отсутствуе в нереляционных СУБД. Созданный сервер может вести работу как с одной, так и с двумя отдельными базами данных.</br>
Кроме MySQL на сервере используется хранилище Redis для хранения сессий клиентов. Таким образом, все сессии хранятся в едином очень быстром хранилище.</br>
На клиентской стороне была создана простейшая страница на HTML, разработан дизайн различных элементов, появляющихся на странице в помощью  CSS.</br>
Основной частью фронтенда является крупный скрипт, созданный с помощью Vue.js. Этот скрипт позволяет использовать только одну страницу для ситуационного отображения объектов, необходимых в конкретный момент.Таким образом, это минимизирует нагрузку на router, ведь ему надо будет для каждого клиента передать определённый набор файлов и два адреса. После этого взаимодействие пользователя с router'ом полностью заканчивается. Это позволяет сильно увеличить скорость ответа маршрутизатора и, как следствие, количество обслуживаемых клиентов за единцу времени.
## Инструкция по запуску
### Необходимое ПО
Созданная система является полностью кроссплатформенной. Все нобходимые компоненты могут быть настроены и запущены на любой операционной системе.</br>
Важно, что Redis официально не поддерживается для Windows, но при этом официальная страница Redis labs даёт ссылку на [репозиторий](https://github.com/dmajkic/redis/downloads), где можно скачать Redis под Windows. Кроме того, в Windows 10 возможна установка компонента Подсистема Windows для Linux, который позволяет запускать оболочку Linux в пользовательском интерфейсе Windows.</br>
Для корректной работы сервиса необходимо установить MySQL Server. На [официальном сайте](https://dev.mysql.com/downloads/) можно также найти все инструкции по установке MySQL.</br>
Для установки Node.js необходимо перейти на [официальный сайт](https://nodejs.org/en/download/) и скачать подходящую сборку.
### Предварительная настройка
Перед запуском основных сервисов необходимо провести настройку их конфигурационных файлов и окружения.</br>
Перед каждым запуском основных сервисов необходимо удостоверится в работе MySQL и Redis. Если не работает Redis, необходимо его запустить командой `redis-server` (запустить `redis-server.exe` из скаченногого архива для Windows). Если не включен MySQL сервер стоит запустить:
- команду `sudo service mysql start` для дистрибутивов Linux Debian u Ubuntu;
- команду `mysql.server start` для Mac OSX;
- MySQL Shell для Windows.
После проверки окружения перед первым запуском необходимо настроить конфигурационные файлы каждого из сервисов.
#### Router
В файл `hosts.json` необходимо внести данные обо всех копиях сервисов taskService и stateService в виде массивов в соответствующие поля.
Для файла `config.json` необходимо внести в:
- `countOfThreads` количество потоков, которые может использовать приложение. Если на машине планируется запускать только данный сервис, то имеет смысл указать значение на единицу меньше чем количество ядер процессора;
- `host` адрес, на котором будет запущен сервис;
- `port` порт, который будет прослушивать сервис;
- `pages` список разрешённых путей и соответствующих им файлов. Настраивать не надо, если сервис запускается без изменений.
#### TaskService и StateService
Для файла `config.json` необходимо внести в:
- `countOfThreads` количество потоков, которые может использовать приложение. Если на машине планируется запускать только данный сервис, то имеет смысл указать значение на единицу меньше чем количество ядер процессора;
- `host` адрес, на котором будет запущен сервис;
- `port` порт, который будет прослушивать сервис;
- `redisHost` адрес, по которому находится запущенное Redis хранилище;
- `redisPort` порт, который прослушивает Redis хранилище;
- `dbHost` адрес MySQL сарвера с базой данных для данного сервиса;
- `dbPort` порт, прослушиваемый MySQL сервером;
- `dbName` название базы данных;
- `dbUser` имя пользователя БД;
- `dbPass` пароль пользователя БД;
- `sessionSecret` строка для шифрования сессий;
- `router` адрес сервиса Router. **Важо помнить**, что адрес, указанный в данном поле должен полностью совпадать с адресом, по которому будет происходить обращение пользователя к router в соответствии с CORS policy.
### Порядок запуска компонентов
Для запуска всех сервисов используется одна и та же команда `node index.js`, выполненная в командной строке или терминале из корневой директории каждого сервиса.</br>
Все сервисы должны запускаться в определённом порядке, иначе первые запросы, направленные на TaskService будут обрабатываться с некоторой задержкой, связанной с получением адреса StateService.
Очередь запуска сервисов:
1. Запустить все экземпляры StateService
2. Запустить Router (только в одном экземпляре, так как он также выступает в виде DNS балансировщика)
3. Запустить все экземпляры TaskService
## Система взаимодействия с сервисами
Основной функционал сервисов заключается во взаимодействии с клиентом с помощью API на основе протокола удалённого вызова функций JSON RPC 2.0 через POST запросы. Данный протокол реализован в системе не в полной мере и с определёнными отступлениями от спецификации 2.0. Во-первых, данной системе не требуются batch-запросы, что избавляет от определения уникальных id запросов. Из-за этого во всех запросах это поле по умолчанию заполнено нулями. Во-вторых, параметры передаются в виде объекта, а не массивом. Данный шаг был произведён для увеличения понятноси API. Последнее отличие от спецификации - это передача некоторых ошибок не специальном поле error, а в поле result. В этих случаях ответ ERROR является именно результатом работы функции, а не ошибкой. Более подробно о структуре запросов, ответов и функционале в целом можно узнать в [описании API](API%20documentation.md).
## Авторизация в системе
Для использования полного функционала необходимо произвести авторизацию в системе. Так как взаимодействие клиента с сервером происходит через протокол HTTP, все подходы к защите можно расположить на отрезке, в начале которого будут находиться совсем ненадёжные методы, а в другом - методы, требующие вычислительные мощности. Для авторизации в системе используется вариант, находящийся ближе к середине этого отрезка. Алгоритм валидации построен на использовании валидации хэшей, полученных с помощью медленной хэш-функции `bcrypt`</br>
Процесс авторизации происходит только через TaskService. В его базе данных хранится имя пользователя, его номер и хэш пароля. Авторизация происходит в два шага.
#### Первый шаг: получение соли
Первый шаг входа в систему состоит в получении клиентом соли (`salt1`), от сервера. Серверу нет необходимости хранить соль в отдельном месте, так как она содержится в первых 29 символах хэша пароля.
#### Второй шаг: валидация
В рамках второго шага, после получения `salt1`, на клиенте дважды выполняет хэширование пароля - первый раз с использованием `salt1`, второй, используя новую случайную соль (`salt2`). После этого полученный хэш передаётся на сервер, на его основе считается хэш функция от данных из базы данных и `salt2` и сравнивается с хэшем клиента.
